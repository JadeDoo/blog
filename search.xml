<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[webpack的使用]]></title>
    <url>%2Fpost%2Fe64c006e%2F</url>
    <content type="text"><![CDATA[安装webpack对项目初始化在命令行输入：npm init主要的作用就是生成一个package.json文件，npm说明文件。webpack安装进行下面命令进行项目安装：npm install -D webpackwebpack4.x版本还需要安装webpack-clinpm install -D webpack-cli查看webpack版本webpack -v入口与出口在项目文件夹中新建两个文件夹src和dist，其中src中放的是源文件，dist是打包后的文件，在新建一个weppack.config.js文件，这是webpack配置文件，虽说webpack4.x号称不需要配置。但因为某些开发，还是配置的比较好。在dist文件夹中创建index.htmldist/index.html123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;在src中创建index.jssrc/index.js1document.getElementsByTagName(&apos;body&apos;).innnerHTML = &apos;Hello Webpack&apos;进行第一次打包webpack4.0已经不支持webpack {entry file} {destination for bundled file}配置webpack.config.js配置之前了解一下基本结构123456789101112131415const config = &#123; //入口文件配置项 entry:&#123;&#125;, //输出文件配置项 output:&#123;&#125;, //模块，各种loader module:&#123;&#125;, //插件 plugins:[], //服务 dexServer:&#123;&#125;, //模式,4.x有两种自定义模式，不过一般不写在配置中 //mode:&#125;module.exports = config;现在开始配置入口文件1234entry:&#123; //入口文件位置 index:&apos;./src/index.js&apos;&#125;输出配置123456output:&#123; //输出位置 path:path.resolve(__dirname,&apos;dist&apos;), //[name]是根据入口文件名字 filename:&apos;[name].js&apos;&#125;基础配置就已经完成了。不过在运行之前还要在配置前面加上const path = require(&#39;path&#39;);完整文件12345678910111213141516171819const path = require(&apos;path&apos;);const config = &#123; //入口文件配置项 entry:&#123; index:&apos;./src/index.js&apos; &#125;, //输出文件配置项 output:&#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;[name].js&apos; &#125;, // 模块，各种loader module:&#123;&#125;, //插件 plugins:[], //服务 devServer:&#123;&#125;,&#125;module.exports = config;输入命令webpack --mode development或者webpack --mode production或者npx webpack第一个是开发，第二个是生产当然米可以在package.json scripts下添加1234&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack --mode development&quot;, &quot;pro&quot;: &quot;webpack --mode production&quot; &#125;以后就可以用 npm run dev/pro进行打包了。服务与热更新#####设置webpack-dev-server下载包npm install webpack-dev-server --save-dev然后在webpack.config.js中配置12345678910devServer:&#123; //设置基本目录结构，服务器运行路径 contentBase:path.resolve(__dirname,&apos;dist&apos;), //服务器的IP地址，可以使用IP也可以是localhost,建议本机IP host:&apos;192.168.2.105&apos;, //服务器压缩 compress:true, //端口号 port:3333&#125;执行命令npx webpack-dev-server发现报错，这是因为没有设置modenpx webpack-dev-server --mode development这时就可以了，我们更改index.js文件查看变化。打开浏览器我们查看是否成功。我们也可以在package.json中添加脚本“scripts”:{“server”:”webpack-dev-server –mode development”}以后启动服务只需要执行命令npm run serverCSS打包进行打包之前，就需要了解一下Loaders，所有Loaders都需要npm安装Loaders的配置项test：用于匹配文件，识别文件的类型，必须的use：loader名称，你使用模块的名称，必须的include/exclude：手动添加的需要处理的文件/不需要处理的文件query：额外的设置选项打包CSS打包CSS需要两个loader —— style-loader和css-loader先下载两个loadernpm install --save-dev style-loader css-loader安装完成就需要配置loader123456module:&#123; rules: [ test: /\.css/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] ]&#125;现在就可以打包了。不过，你也得有css。。。。新建一个CSS文件src/css/index.css1234body &#123; background: red;&#125;你打包后并没有什么用。。。你还需要将入口文件修改，添加一句。import css from &#39;./css/index.css&#39;;JS压缩在webpack4.x中，生产模式下webpack会自动压缩代码，所以亦可以不配置，但是如果有额外的设置，还是需要手动配置一下。JS插件压缩需要一个插件。uglifyjs-webpack-plugin,不过，webpack已经集成了这个plugin。引入插件在配置文件webpack.config.js添加const uglify = require(&#39;uglifyjs-webpack-plugin&#39;)引入后在plugins配置里new一个 uglify对象就可以了123plugins: [ new uglify()]HTML文件到现在我们的html直接放在dist文件夹中，所有文件就应该一个源文件夹一个生产文件夹。我们将html文件移动到src文件夹中，去掉js引入代码，webpack会自动帮我们完成这些事。安装插件npm install --save-dev html-webpack-plugin配置配置与js压缩插件同理，不过html插件多了一个参数。const htmlPlugin = require(&#39;html-webpack-plugin&#39;);12345678new htmlPlugin(&#123; minify:&#123; removeAttributeQuotes:true &#125;, hash:true, template:&apos;./src/index.html&apos;&#125;)打包图片首先随便找一张图片，最好两张，后面有用，一张小的，一张大的。。。修改源文件html，添加一个div。&lt;div id=&quot;img&quot;&gt;&lt;/div&gt;修改CSS文件123#img&#123; background-image:url(../images/img1.jpg);&#125;下载两个解析图片的loadernpm install -D file-loader url-loaderfile-loader解决引用路径的问题，拿background样式用url引入背景图来说，我们都知道，webpack最终会将各个模块打包成一个文件，因此我们样式中的url路径是相对入口html页面的，而不是相对于原始css文件所在的路径的。这就会导致图片引入失败。这个问题是用file-loader解决的，file-loader可以解析项目中的url引入（不仅限于css），根据我们的配置，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件。url-loader如果图片较多，会发很多http请求，会降低页面性能。这个问题可以通过url-loader解决。url-loader会将引入的图片编码，生成dataURl。相当于把图片数据翻译成一串字符。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了。当然，如果图片较大，编码会消耗性能。因此url-loader提供了一个limit参数，小于limit字节的文件会被转为DataURl，大于limit的还会使用file-loader进行copy。配置12345678910111213141516module:&#123; rules [ &#123; test: /\.(png|jpg|gif)$/, loader:[ &#123; loader:&apos;url-loader&apos;, options:&#123; // 把小于300000B的图片打包为base64的格式i，写入js limit:300000 &#125; &#125; ] &#125; ]&#125;为什么只用了url-loaderurl-loader封装了file-loaderCSS分离和图片路径问题在webpack中extract-text-webpack-plugin也完成了其历史使命，将让位于mini-css-extract-plugin安装npm i -D mini-css-extract-plugin配置12345678910111213141516171819202122const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);module.exports = &#123; plugins: [ new MiniCssExtractPlugin(&#123; // Options similar to the same options in webpackOptions.output // both options are optional filename: &quot;[name].css&quot;, chunkFilename: &quot;[id].css&quot; &#125;) ], module: &#123; rules: [ &#123; test: /\.css$/, use: [ MiniCssExtractPlugin.loader, // replace ExtractTextPlugin.extract(&#123;..&#125;) &quot;css-loader&quot; ] &#125; ] &#125;&#125;css图片路径解决在output中设置publicPath，处理静态资源。12345output:&#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;[name].js&apos;, publicPath:&quot;http://http://192.168.2.105:3333/&quot; &#125;html中的图片html中用img标签引入的图片可以用html-loader也可以用html-withimg-loader。安装npm i -D html-withimg-loader配置1234&#123; test: /\.(html|htm)$/i, loader: [&apos;html-withimg-loader&apos;]&#125;打包Less和Sass安装打包less和sass需要安装它们的服务npm i -D lessnpm i -D node-sass当然还需要安装两个losdernpm i -D less-loader sass-loader配置1234567&#123; test: /\.less$/, loader: [&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;less-loader&apos;]&#125;,&#123; test:/\.scss$/, loader:[&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;sass-loader&apos;]&#125;分离less和sass和css分离一样1234&#123; test:/\.less$/, loader:[MiniCssExtractPlugin.loader,&apos;css-loader&apos;,&apos;less-loader&apos;]&#125;sass同理CSS自动处理前缀需要安装两个包postcss-loader 和autoprefixer（自动添加前缀的插件）npm i -D postcss-loader autoprefixer配置建立一个postcss.config.js与webpack.config.js同级postcss.config.js12345module.exports = &#123; plugins:[ require(&apos;autoprefixer&apos;) ]&#125;配置loader将postcss-loader push 到loder当中1234&#123; test: /\.css$/, loader: [miniCssExtractPlugin.loader, &apos;css-loader&apos;,&apos;postcss-loader&apos;] &#125;自动处理未使用的css安装purifycss-webpack依赖purify-css这个包npm i -D purifycss-webpack purify-css配置我们需要同步检查html模板，所以还需要nodejs的glob对象引入globconst glob = require(&#39;glob&#39;)引入插件const purifyCssPlugin = require(&#39;purifycss-webpack&#39;)配置plugins1234new PurifyCSSPlugin(&#123; // 配置path，寻找到所有的html paths: glob.sync(path.join(__dirname, &apos;src/*.html&apos;)), &#125;)转义ES6/ES7/jsx安装npm i babel-core babel-loader babel-preset-env babel-preset-stage-0 babel-preset-react -D配置123456789101112&#123; test:/\.jsx?$/, loader: &#123; loader: &apos;babel&apos;, options:&#123; // es6 es7 react presets:[&apos;env&apos;,&apos;stage-0&apos;,&apos;react&apos;] &#125; &#125;, include:path.jion(__dirname,&apos;./src&apos;), exclude:/node_modules/&#125;打包后的调试配置一个`devtool:’eval-source-map’，一个有四种模式source-map:在一个单独文件中产生一个完整且功能完全的文件。这个文件具有最好的source map,但是它会减慢打包速度；cheap-module-source-map:在一个单独的文件中产生一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号）,会对调试造成不便。eval-source-map:使用eval打包源文件模块，在同一个文件中生产干净的完整版的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定要不开启这个选项。cheap-module-eval-source-map:这是在打包文件时最快的生产source map的方法，生产的 Source map 会和打包后的JavaScript文件同行显示，没有影射列，和eval-source-map选项具有相似的缺点。12345678module.exports = &#123; devtool: &apos;eval-source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname + &quot;/public&quot;, filename: &quot;bundle.js&quot; &#125;&#125;模块化配置JS实现模块化写一个最简单的es6模块化代码，把add方法暴露出去1234function add(a,b)&#123; retrun a+b&#125;module.exports = add;然后在入口文件中引入12import add from &apos;./add.js&apos;;add(1,2);webpack模块化webpack模块化和js类似我们把入口文件进行模块化配置，单独制成一个模块。在根目录建一个webpack_config文件夹，然后新建entry_webpack.js文件entry_webpack.js12345const entry = &#123;&#125;;entry.path = &#123; entry:&apos;./sc/entry.js&apos;&#125;module.exports = entry;在webpack.config.js中引入1const entry = require(&apos;./webpack_config/entry_webpack.js&apos;);然后在入口文件修改1entry : entry.path引入第三方库以JQuery为例安装npm i --save jquery我们需要在生产环境中使用，用 –save安装引入import $ from jquery测试$(‘#title’).html(&#39;Hello JQuery&#39;)用pligin引入ProvidePlugin是webpack自带的插件const webpack = require(&#39;webpack&#39;)配置plugins12345plugins:[ new webpack.ProvidePlugin(&#123; $:&apos;jquery&apos; &#125;)]watchwatch的配置12345678watchOptions:&#123; //检测修改的时间 poll:1000, //防止重复保存编译错误 aggregateTimeout:500, //不监听的目录 ignored:/node_modules/&#125;文件代码注释new webpack.BannerPlugin(&#39;作者：xxx&#39;)优化ProvidePlugin和importimport引入方法：引用后不管你在代码中使用不适用该类库，都会把该类库打包起来，这样有时就会让代码产生冗余。ProvidePlugin引入方法：引用后只有在类库使用时，才按需进行打包，所以建议在工作使用插件的方式进行引入。代码抽离在新版中我们废弃并移除了 CommonsChunkPlugin，并且使用一些默认值以及更容易被复写的新 API optimize.splitChunks 来代替它。静态资源集中输出npm i -D copy-webpack-pligin同样的引入，配置1234new copyWebpackPlugin([&#123; from:__diname + &apos;/src/public&apos;, to:&apos;./public&apos;&#125;])from:要打包的静态资源目录地址，这里的__dirname是指项目目录下，是node的一种语法，可以直接定位到本机的项目目录中。to:要打包到的文件夹路径，跟随output配置中的目录。所以不需要再自己加__dirname。json打包前清空distnpm i -D clean-webpack-plugin123plugins:[ new cleanWebpackPlugin([path.join(__dirname,&apos;dist&apos;)])]]]></content>
      <categories>
        <category>技术类</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack]]></title>
    <url>%2Fpost%2Fb9f20a20%2F</url>
    <content type="text"><![CDATA[写这篇文章的只是一个前端小白，如果有错误的地方，还请指出来。。。什么是webpack？webpack简单的来说就是一个打包器。处理应用程序的时候，它会创建一个依赖关系图，然后将这些模块打包一个或多个bundle。webpack4.0之后，可以不用引入配置文件。###Entry所有的webpack配置都写在webpack.config.js文件里入口文件配置1234const config = &#123; entry: &apos;./src/index.js&apos;&#125;;module.exports = config;多个页面应用程序1234567const config = &#123; entry: &#123; page1: &apos;./src/page1/index.js&apos;, page2: &apos;./src/page2/index.js&apos; &#125;&#125;;module.exports = config;每个 HTML 文档只使用一个入口起点。###Output1234567891011const config = &#123; entry: &#123; page1: &apos;./src/page1/index.js&apos;, page2: &apos;./src/page2/index.js&apos; &#125;, output: &#123; filename: &apos;[name].bundle.js&apos;, path: __dirname + &apos;/dist&apos; &#125;&#125;;module.exports = config;###Modewebpack一个有两种模式，production和developement可以在配置文件中写入123module.exports = &#123; mode: &apos;production&apos;&#125;或者在CLI中传递参数webpack –mode=production###Loderloder用于转换其他格式的文件，webpack本身只能识别js。要使用loder你需要先下载对应的lodernpm install --save-dev css-loder在webpack.config.js中配置loder1234567891011121314module: &#123; rules: [ test: /\.css$/, use: [ &#123;loader: &apos;style-loader&apos;&#125;, &#123; loder:&apos;css-loader&apos;, options:&#123; modules: true &#125; &#125; ] ]&#125;###Plugins12345678910111213141516171819202122232425const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //通过 npm 安装const webpack = require(&apos;webpack&apos;); //访问内置的插件const path = require(&apos;path&apos;);const config = &#123; entry: &apos;./path/to/my/entry/file.js&apos;, output: &#123; filename: &apos;my-first-webpack.bundle.js&apos;, path: path.resolve(__dirname, &apos;dist&apos;) &#125;, module: &#123; rules: [ &#123; test: /\.(js|jsx)$/, use: &apos;babel-loader&apos; &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: &apos;./src/index.html&apos;&#125;) ]&#125;;module.exports = config;]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VS Code前端插件]]></title>
    <url>%2Fpost%2F71cfa6a3%2F</url>
    <content type="text"><![CDATA[名称功能Auto Close Tag自动闭合HTML标签Auto Import Typescript自动import提示Auto Rename Tag修改HTML标签时，自动修改匹配的标签Beautify格式化javascript，JSON，CSS，Sass，和HTMLClass autocomplete for HTML智能提示HTML class =“”属性（必备）Bracket Pair Colorizer颜色识别匹配括号Code Runner运行选中代码段（支持大量语言，包括Node）css peek能够查看CSS ID和类的字符串作为HTML文件中相应的CSS定义（必备）Color Highlight颜色值在代码中高亮显示Color Info小窗口显示颜色值，rgb,hsl,cmyk,hex等等Document This添加注释块(Ctrl+alt+d)ESLintESLint插件，高亮提示Git History以图表的形式查看git日志(Ctrl+shift+p)HTML CSS Support在 html 标签上写class 智能提示当前项目所支持的样式（必备）HTML Snippetshtml 代码片段（必备）htmlhinthtml代码检测htmltagwrap可以在选中HTML标签中外面套一层标签(Alt + W)IntelliSense for CSS class names智能提示 css 的 class 名JavaScript (ES6) code snippetses6代码片段（必备）JavaScript Snippet Packjs代码片段（必备）Live Sass Compiler实时编译 sassopen in browser当前的 html 文件用浏览器打开(alt+b)Output Colorizer输出提示的文字颜色有一些变化，方便获取关键信息Path Intellisense路径自动补全（必备）Sass写 sass 必备Quokka.js实时观看 javascript 的变量的变化(shift+cmd+p （ctrl+shift+p）输入quokka选择new javascript)Regex Previewer测试正则的插件vscode-icons目录树图标Dracula Official主题插件。。。React-Native/React/Redux snippets for es6/es7react代码片段react-beautify格式化 javascript, JSX, typescript, TSX 文件veturvue语法高亮、智能感知VueHelpervue代码片段Vue TypeScript Snippetsvue的 typescript 代码片段Vue 2 Snippetsvue 2代码片段]]></content>
      <categories>
        <category>应用类</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub利用Hexo搭建博客]]></title>
    <url>%2Fpost%2Fc3d89d7f%2F</url>
    <content type="text"><![CDATA[想要利用hexo和GitHub page搭建自己的博客，首先就要安装必要的工具。 在那之前你需要在Github上注册一个账号。第一：安装nodejs不会安装的可以看我的另外一篇文章 传送门第二：安装git直接到官网下载安装包，傻瓜式安装。 传送门。配置git在任意地方右键运行git bash，执行命令12$ git config --global user.name &quot;yourname&quot;$ git config --global user.email &quot;youremail&quot;其中yourname为你的GitHub名，youremail为你的GitHub邮箱。继续执行1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;可以在用户文件夹里看到一个.ssh文件，打开其中的.pub后缀名的文件，复制里面的内容。打开GitHub网站，点击头像，选择setting，找到 SSH and GPG keys点击右侧的new SSH key把刚才复制的内容粘贴到key里第三：安装hexo新建一个已准备存放blog的文件夹，在该文件目录下右键运行git bash here，输入npm i -g hexo，执行完毕后，输入hexo -v，出现版本号证明安装成功。第四：配置在BLOG文件夹中运行git bash，然后执行初始化命令$ hexo init。这时候hexo会自动生成说需要的文件。执行完毕之后我们可以执行$ hexo s --debug命令打开hexo自带的服务器，默认端口号为4000。点击localhost:4000如果成功的话就可以看见hexo默认的模板页面，用$ hexo new page &quot;name&quot;新建文章，你可以随便写点内容，现在我们就要将它发布到网上去。不过在那之前，还需要在GitHub上新建一个仓库和配置一下站点配置文件打开blog文件根目录中找到config.yml文件，修改里面的部分内容。###第五：关联仓库在此之前需要创建一个仓库点击New reporitory，新建仓库。注意这里的仓库名称必须是此格式，yourname.github.io。其中yourname是你的github名称。仓库有了，把本地blog上传到仓库。执行$ hexo g -d命令。一切准备就绪，可以打开你的个人博客。GitHub page 网站格式 yourname.github.io]]></content>
      <categories>
        <category>应用类</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用3M安装nodejs]]></title>
    <url>%2Fpost%2Fc80c1044%2F</url>
    <content type="text"><![CDATA[nodejs在window下安装nodejs有很多中安装方式，本篇文章使用的是nvm(nodejs version manager,版本管理工具)方式来进行安装。详情请查看【官方文档】。安装nvm首先下载nvm包,我们选择我们需要的免安装版:nvm-noinstall.zip,下载完成后解压,解压到你想要解压的地方就好,例如:C:\dev\nvm,文件包含:elevate.cmdelevate.vbsinstall.cmdLICENSEnvm.exe运行install.cmd,直接回车,会在C盘的根目录下生成settings.txt文件，将这个文件剪切到C:\dev\nvm目录中修改其中的内容root: C:\dev\nvmpath: C:\dev\nodejsproxy: nonenode_mirror: http://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/配置环境变量，运行了install.cmd，所以直接在环境变量中找到并修改NVM_HOME:C:\dev\nvm,NVM_SYMLINK:C:\dev\nodejs然后修改path，如果发现path中有路径C:\dev\nvm，就将它删除，我们自己在最前面添加’ ;%NVM_HOME%;%NVM_SYMLINK%;’运行cmd，输入 ‘nvm -v’ 显示版本号证明安装成功，注意它会显示一堆东西，往上拉就可以看见版本号,然后就可以安装nodejs了。输入 nvm install lastest 安装最新版的nodejs，如果不想下载最新版则输入nvm install 版本号，例如 nvm install 7.9.0，32位的电脑还得在后面添加一个32。这是打开C:\dev会发现有一个noedjs文件夹的快捷方式，它指向的就是C:\dev\nvm中nodejs的版本文件夹，例如v7.9.0运用nvm可以进行版本切换，nvm use 版本号，前提是得有这个版本。输入nvm list 可以查看目前安装了几个nodejs版本和正在使用哪个版本。安装npmnpm(nodejs package manager，nodejs包管理工具)，每一个版本的nodejs都会自带一个npm，但是有时候明明安装了包，却无法使用，其中就有可能是因为版本切换问题而引起的，所以需要安装一个全局的npm。运行cmd，输入npm config set prefix “C:\dev\nvm\npm，运行完成后可以在用户文件夹中找到一个.npmrc的文件，里面存的是一个路径。继续输入npm install npm -g，等待下载。这是可以在C:\dev\nvm\npm中查看文件，以后需要安装全局包在后面加一个-g就好了。当然，需要单独为全局npm配置环境变量NPM_HOME:C:\dev\nvm\npm在path最前面加上;%NPM_HOME%，这个是必须加载%NVM_SYMLINK%之前的，输入 npm -v 显示版本号证明安装成功。安装nrmnrm(npm registry manager，npm的镜像源管理工具)，这是为了切换镜像源，为什么需要？有时候国外的资源太慢，我们需要切换国内的资源点。运行cmd，输入npm install -g nrm，等待下载安装完毕。输入nrm ls，可以查看所有的可切换源地址。一般来说国内的肯定比国外的要快，所以我们一般用淘宝的镜像地址，输入nrm use cnpm就可以切换了。]]></content>
      <categories>
        <category>应用类</category>
      </categories>
      <tags>
        <tag>NodeJs</tag>
      </tags>
  </entry>
</search>

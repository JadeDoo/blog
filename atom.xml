<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JadeDoo</title>
  
  <subtitle>JadeDoo</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jadedoo.github.io/"/>
  <updated>2018-04-23T14:09:18.996Z</updated>
  <id>https://jadedoo.github.io/</id>
  
  <author>
    <name>Jade Doo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webpack的使用</title>
    <link href="https://jadedoo.github.io/post/e64c006e/"/>
    <id>https://jadedoo.github.io/post/e64c006e/</id>
    <published>2018-04-19T19:22:48.000Z</published>
    <updated>2018-04-23T14:09:18.996Z</updated>
    
    <content type="html"><![CDATA[<h4 id="安装webpack"><a href="#安装webpack" class="headerlink" title="安装webpack"></a>安装webpack</h4><h5 id="对项目初始化"><a href="#对项目初始化" class="headerlink" title="对项目初始化"></a>对项目初始化</h5><p>在命令行输入：<br><code>npm init</code></p><p>主要的作用就是生成一个package.json文件，npm说明文件。</p><h5 id="webpack安装"><a href="#webpack安装" class="headerlink" title="webpack安装"></a>webpack安装</h5><p>进行下面命令进行项目安装：<br><code>npm install -D webpack</code></p><p>webpack4.x版本还需要安装webpack-cli<br><code>npm install -D webpack-cli</code></p><h5 id="查看webpack版本"><a href="#查看webpack版本" class="headerlink" title="查看webpack版本"></a>查看webpack版本</h5><p><code>webpack -v</code></p><hr><h4 id="入口与出口"><a href="#入口与出口" class="headerlink" title="入口与出口"></a>入口与出口</h4><p>在项目文件夹中新建两个文件夹src和dist，其中src中放的是源文件，dist是打包后的文件，在新建一个weppack.config.js文件，这是webpack配置文件，虽说webpack4.x号称不需要配置。但因为某些开发，还是配置的比较好。<br>在dist文件夹中创建index.html</p><h5 id="dist-index-html"><a href="#dist-index-html" class="headerlink" title="dist/index.html"></a>dist/index.html</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在src中创建index.js</p><h5 id="src-index-js"><a href="#src-index-js" class="headerlink" title="src/index.js"></a>src/index.js</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementsByTagName(&apos;body&apos;).innnerHTML = &apos;Hello Webpack&apos;</span><br></pre></td></tr></table></figure><h5 id="进行第一次打包"><a href="#进行第一次打包" class="headerlink" title="进行第一次打包"></a>进行第一次打包</h5><p>webpack4.0已经不支持<code>webpack {entry file} {destination for bundled file}</code></p><h5 id="配置webpack-config-js"><a href="#配置webpack-config-js" class="headerlink" title="配置webpack.config.js"></a>配置webpack.config.js</h5><p>配置之前了解一下基本结构<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const config = &#123;</span><br><span class="line">//入口文件配置项</span><br><span class="line">entry:&#123;&#125;,</span><br><span class="line">    //输出文件配置项</span><br><span class="line">    output:&#123;&#125;,</span><br><span class="line">    //模块，各种loader</span><br><span class="line">    module:&#123;&#125;,</span><br><span class="line">    //插件</span><br><span class="line">    plugins:[],</span><br><span class="line">    //服务</span><br><span class="line">    dexServer:&#123;&#125;,</span><br><span class="line">    //模式,4.x有两种自定义模式，不过一般不写在配置中</span><br><span class="line">    //mode:</span><br><span class="line">&#125;</span><br><span class="line">module.exports = config;</span><br></pre></td></tr></table></figure><p></p><p>现在开始配置入口文件<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry:&#123;</span><br><span class="line">//入口文件位置</span><br><span class="line">index:&apos;./src/index.js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出配置<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">output:&#123;</span><br><span class="line">//输出位置</span><br><span class="line">path:path.resolve(__dirname,&apos;dist&apos;),</span><br><span class="line">    //[name]是根据入口文件名字</span><br><span class="line">    filename:&apos;[name].js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>基础配置就已经完成了。不过在运行之前还要在配置前面加上<br><code>const path = require(&#39;path&#39;);</code></p><p>完整文件<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const config = &#123;</span><br><span class="line">//入口文件配置项</span><br><span class="line">entry:&#123;</span><br><span class="line">        index:&apos;./src/index.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    //输出文件配置项</span><br><span class="line">    output:&#123;</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">        filename: &apos;[name].js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 模块，各种loader</span><br><span class="line">    module:&#123;&#125;,</span><br><span class="line">    //插件</span><br><span class="line">    plugins:[],</span><br><span class="line">    //服务</span><br><span class="line">    devServer:&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">module.exports = config;</span><br></pre></td></tr></table></figure><p></p><p>输入命令<br><code>webpack --mode development</code>或者<code>webpack --mode production</code>或者<code>npx webpack</code><br>第一个是开发，第二个是生产<br>当然米可以在package.json scripts下添加<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">   &quot;dev&quot;: &quot;webpack --mode development&quot;,</span><br><span class="line">   &quot;pro&quot;: &quot;webpack --mode production&quot;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p></p><p>以后就可以用 <code>npm run dev/pro</code>进行打包了。</p><h4 id="服务与热更新"><a href="#服务与热更新" class="headerlink" title="服务与热更新"></a>服务与热更新</h4><p>#####设置webpack-dev-server<br>下载包<br><code>npm install webpack-dev-server --save-dev</code></p><p>然后在webpack.config.js中配置<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">//设置基本目录结构，服务器运行路径</span><br><span class="line">    contentBase:path.resolve(__dirname,&apos;dist&apos;),</span><br><span class="line">    //服务器的IP地址，可以使用IP也可以是localhost,建议本机IP</span><br><span class="line">    host:&apos;192.168.2.105&apos;,</span><br><span class="line">    //服务器压缩</span><br><span class="line">    compress:true,</span><br><span class="line">    //端口号</span><br><span class="line">    port:3333</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>执行命令<br><code>npx webpack-dev-server</code><br>发现报错，这是因为没有设置mode<br><code>npx webpack-dev-server --mode development</code><br>这时就可以了，我们更改index.js文件查看变化。<br>打开浏览器我们查看是否成功。<br>我们也可以在package.json中添加脚本<br>“scripts”:{<br>“server”:”webpack-dev-server –mode development”<br>}<br>以后启动服务只需要执行命令<br><code>npm run server</code></p><h4 id="CSS打包"><a href="#CSS打包" class="headerlink" title="CSS打包"></a>CSS打包</h4><p>进行打包之前，就需要了解一下Loaders，所有Loaders都需要npm安装</p><h5 id="Loaders的配置项"><a href="#Loaders的配置项" class="headerlink" title="Loaders的配置项"></a>Loaders的配置项</h5><ul><li>test：用于匹配文件，识别文件的类型，必须的</li><li>use：loader名称，你使用模块的名称，必须的</li><li>include/exclude：手动添加的需要处理的文件/不需要处理的文件</li><li>query：额外的设置选项</li></ul><h5 id="打包CSS"><a href="#打包CSS" class="headerlink" title="打包CSS"></a>打包CSS</h5><p>打包CSS需要两个loader —— <code>style-loader</code>和<code>css-loader</code><br>先下载两个loader<br><code>npm install --save-dev style-loader css-loader</code></p><p>安装完成就需要配置loader<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">rules: [</span><br><span class="line">    test: /\.css/,</span><br><span class="line">        use: [&apos;style-loader&apos;, &apos;css-loader&apos;]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>现在就可以打包了。<br>不过，你也得有css。。。。<br>新建一个CSS文件</p><h5 id="src-css-index-css"><a href="#src-css-index-css" class="headerlink" title="src/css/index.css"></a>src/css/index.css</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">    background: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你打包后并没有什么用。。。<br>你还需要将入口文件修改，添加一句。<br><code>import css from &#39;./css/index.css&#39;;</code></p><h4 id="JS压缩"><a href="#JS压缩" class="headerlink" title="JS压缩"></a>JS压缩</h4><p>在webpack4.x中，生产模式下webpack会自动压缩代码，所以亦可以不配置，但是如果有额外的设置，还是需要手动配置一下。<br>JS插件压缩需要一个插件。<code>uglifyjs-webpack-plugin</code>,不过，webpack已经集成了这个plugin。</p><h5 id="引入插件"><a href="#引入插件" class="headerlink" title="引入插件"></a>引入插件</h5><p>在配置文件webpack.config.js添加<br><code>const uglify = require(&#39;uglifyjs-webpack-plugin&#39;)</code></p><p>引入后在plugins配置里new一个 uglify对象就可以了<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">new uglify()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p></p><h4 id="HTML文件"><a href="#HTML文件" class="headerlink" title="HTML文件"></a>HTML文件</h4><p>到现在我们的html直接放在dist文件夹中，所有文件就应该一个源文件夹一个生产文件夹。<br>我们将html文件移动到src文件夹中，去掉js引入代码，webpack会自动帮我们完成这些事。</p><h5 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h5><p><code>npm install --save-dev html-webpack-plugin</code></p><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>配置与js压缩插件同理，不过html插件多了一个参数。<br><code>const htmlPlugin = require(&#39;html-webpack-plugin&#39;);</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">new htmlPlugin(&#123;</span><br><span class="line">minify:&#123;</span><br><span class="line">    removeAttributeQuotes:true</span><br><span class="line">    &#125;,</span><br><span class="line">    hash:true,</span><br><span class="line">    template:&apos;./src/index.html&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="打包图片"><a href="#打包图片" class="headerlink" title="打包图片"></a>打包图片</h4><p>首先随便找一张图片，最好两张，后面有用，一张小的，一张大的。。。<br>修改源文件html，添加一个div。<br><code>&lt;div id=&quot;img&quot;&gt;&lt;/div&gt;</code></p><p>修改CSS文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#img&#123;</span><br><span class="line">background-image:url(../images/img1.jpg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下载两个解析图片的loader<br><code>npm install -D file-loader url-loader</code></p><h5 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h5><p>解决引用路径的问题，拿background样式用url引入背景图来说，我们都知道，webpack最终会将各个模块打包成一个文件，因此我们样式中的url路径是相对入口html页面的，而不是相对于原始css文件所在的路径的。这就会导致图片引入失败。这个问题是用file-loader解决的，file-loader可以解析项目中的url引入（不仅限于css），根据我们的配置，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件。</p><h5 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h5><p>如果图片较多，会发很多http请求，会降低页面性能。这个问题可以通过url-loader解决。url-loader会将引入的图片编码，生成dataURl。相当于把图片数据翻译成一串字符。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了。当然，如果图片较大，编码会消耗性能。因此url-loader提供了一个limit参数，小于limit字节的文件会被转为DataURl，大于limit的还会使用file-loader进行copy。</p><h5 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">rules [</span><br><span class="line">    &#123;</span><br><span class="line">        test: /\.(png|jpg|gif)$/,</span><br><span class="line">            loader:[</span><br><span class="line">            &#123;</span><br><span class="line">                loader:&apos;url-loader&apos;,</span><br><span class="line">                    options:&#123;</span><br><span class="line">                    // 把小于300000B的图片打包为base64的格式i，写入js</span><br><span class="line">                    limit:300000</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="为什么只用了url-loader"><a href="#为什么只用了url-loader" class="headerlink" title="为什么只用了url-loader"></a>为什么只用了url-loader</h5><p>url-loader封装了file-loader</p><h4 id="CSS分离和图片路径问题"><a href="#CSS分离和图片路径问题" class="headerlink" title="CSS分离和图片路径问题"></a>CSS分离和图片路径问题</h4><p>在webpack中extract-text-webpack-plugin也完成了其历史使命，将让位于mini-css-extract-plugin</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p><code>npm i -D mini-css-extract-plugin</code></p><h5 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      // Options similar to the same options in webpackOptions.output</span><br><span class="line">      // both options are optional</span><br><span class="line">      filename: &quot;[name].css&quot;,</span><br><span class="line">      chunkFilename: &quot;[id].css&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,  // replace ExtractTextPlugin.extract(&#123;..&#125;)</span><br><span class="line">          &quot;css-loader&quot;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="css图片路径解决"><a href="#css图片路径解决" class="headerlink" title="css图片路径解决"></a>css图片路径解决</h5><p>在output中设置publicPath，处理静态资源。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output:&#123;</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">        filename: &apos;[name].js&apos;,</span><br><span class="line">        publicPath:&quot;http://http://192.168.2.105:3333/&quot;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p></p><h5 id="html中的图片"><a href="#html中的图片" class="headerlink" title="html中的图片"></a>html中的图片</h5><p>html中用img标签引入的图片可以用<code>html-loader</code>也可以用<code>html-withimg-loader</code>。</p><h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><p><code>npm i -D html-withimg-loader</code></p><h5 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">test: /\.(html|htm)$/i,</span><br><span class="line">    loader: [&apos;html-withimg-loader&apos;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打包Less和Sass"><a href="#打包Less和Sass" class="headerlink" title="打包Less和Sass"></a>打包Less和Sass</h4><h5 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h5><p>打包less和sass需要安装它们的服务<br><code>npm i -D less</code><br><code>npm i -D node-sass</code><br>当然还需要安装两个losder<br><code>npm i -D less-loader sass-loader</code></p><h5 id="配置-4"><a href="#配置-4" class="headerlink" title="配置"></a>配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">test: /\.less$/,</span><br><span class="line">    loader: [&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;less-loader&apos;]</span><br><span class="line">&#125;,&#123;</span><br><span class="line">test:/\.scss$/,</span><br><span class="line">    loader:[&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;sass-loader&apos;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="分离less和sass"><a href="#分离less和sass" class="headerlink" title="分离less和sass"></a>分离less和sass</h5><p>和css分离一样<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">test:/\.less$/,</span><br><span class="line">    loader:[MiniCssExtractPlugin.loader,&apos;css-loader&apos;,&apos;less-loader&apos;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>sass同理</p><h4 id="CSS自动处理前缀"><a href="#CSS自动处理前缀" class="headerlink" title="CSS自动处理前缀"></a>CSS自动处理前缀</h4><p>需要安装两个包postcss-loader 和autoprefixer（自动添加前缀的插件）<br><code>npm i -D postcss-loader autoprefixer</code></p><h5 id="配置-5"><a href="#配置-5" class="headerlink" title="配置"></a>配置</h5><p>建立一个postcss.config.js与webpack.config.js同级</p><h6 id="postcss-config-js"><a href="#postcss-config-js" class="headerlink" title="postcss.config.js"></a>postcss.config.js</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    plugins:[</span><br><span class="line">        require(&apos;autoprefixer&apos;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="配置loader"><a href="#配置loader" class="headerlink" title="配置loader"></a>配置loader</h6><p>将postcss-loader push 到loder当中<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.css$/,</span><br><span class="line">    loader: [miniCssExtractPlugin.loader, &apos;css-loader&apos;,&apos;postcss-loader&apos;]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="自动处理未使用的css"><a href="#自动处理未使用的css" class="headerlink" title="自动处理未使用的css"></a>自动处理未使用的css</h4><h5 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h5><p>purifycss-webpack依赖purify-css这个包<br><code>npm i -D purifycss-webpack purify-css</code></p><h5 id="配置-6"><a href="#配置-6" class="headerlink" title="配置"></a>配置</h5><p>我们需要同步检查html模板，所以还需要nodejs的glob对象<br>引入glob<code>const glob = require(&#39;glob&#39;)</code><br>引入插件<code>const purifyCssPlugin = require(&#39;purifycss-webpack&#39;)</code><br>配置plugins<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new PurifyCSSPlugin(&#123;</span><br><span class="line">        // 配置path，寻找到所有的html</span><br><span class="line">        paths: glob.sync(path.join(__dirname, &apos;src/*.html&apos;)),</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p></p><h4 id="转义ES6-ES7-jsx"><a href="#转义ES6-ES7-jsx" class="headerlink" title="转义ES6/ES7/jsx"></a>转义ES6/ES7/jsx</h4><h5 id="安装-4"><a href="#安装-4" class="headerlink" title="安装"></a>安装</h5><p><code>npm i babel-core babel-loader babel-preset-env babel-preset-stage-0 babel-preset-react -D</code></p><h5 id="配置-7"><a href="#配置-7" class="headerlink" title="配置"></a>配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">test:/\.jsx?$/,</span><br><span class="line">    loader: &#123;</span><br><span class="line">    loader: &apos;babel&apos;,</span><br><span class="line">        options:&#123;</span><br><span class="line">        //       es6     es7      react</span><br><span class="line">        presets:[&apos;env&apos;,&apos;stage-0&apos;,&apos;react&apos;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    include:path.jion(__dirname,&apos;./src&apos;),</span><br><span class="line">    exclude:/node_modules/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打包后的调试"><a href="#打包后的调试" class="headerlink" title="打包后的调试"></a>打包后的调试</h4><p>配置一个`devtool:’eval-source-map’，一个有四种模式</p><ul><li>source-map:在一个单独文件中产生一个完整且功能完全的文件。这个文件具有最好的source map,但是它会减慢打包速度；</li><li>cheap-module-source-map:在一个单独的文件中产生一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号）,会对调试造成不便。</li><li>eval-source-map:使用eval打包源文件模块，在同一个文件中生产干净的完整版的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定要不开启这个选项。</li><li>cheap-module-eval-source-map:这是在打包文件时最快的生产source map的方法，生产的 Source map 会和打包后的JavaScript文件同行显示，没有影射列，和eval-source-map选项具有相似的缺点。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  devtool: &apos;eval-source-map&apos;,</span><br><span class="line">  entry:  __dirname + &quot;/app/main.js&quot;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + &quot;/public&quot;,</span><br><span class="line">    filename: &quot;bundle.js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模块化配置"><a href="#模块化配置" class="headerlink" title="模块化配置"></a>模块化配置</h4><h5 id="JS实现模块化"><a href="#JS实现模块化" class="headerlink" title="JS实现模块化"></a>JS实现模块化</h5><p>写一个最简单的es6模块化代码，把add方法暴露出去<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function add(a,b)&#123;</span><br><span class="line">retrun a+b</span><br><span class="line">&#125;</span><br><span class="line">module.exports = add;</span><br></pre></td></tr></table></figure><p></p><p>然后在入口文件中引入<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import add from &apos;./add.js&apos;;</span><br><span class="line">add(1,2);</span><br></pre></td></tr></table></figure><p></p><h5 id="webpack模块化"><a href="#webpack模块化" class="headerlink" title="webpack模块化"></a>webpack模块化</h5><p>webpack模块化和js类似<br>我们把入口文件进行模块化配置，单独制成一个模块。<br>在根目录建一个webpack_config文件夹，然后新建entry_webpack.js文件</p><h6 id="entry-webpack-js"><a href="#entry-webpack-js" class="headerlink" title="entry_webpack.js"></a>entry_webpack.js</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const entry = &#123;&#125;;</span><br><span class="line">entry.path = &#123;</span><br><span class="line">entry:&apos;./sc/entry.js&apos;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = entry;</span><br></pre></td></tr></table></figure><p>在webpack.config.js中引入<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const entry = require(&apos;./webpack_config/entry_webpack.js&apos;);</span><br></pre></td></tr></table></figure><p></p><p>然后在入口文件修改<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry : entry.path</span><br></pre></td></tr></table></figure><p></p><h5 id="引入第三方库"><a href="#引入第三方库" class="headerlink" title="引入第三方库"></a>引入第三方库</h5><p>以JQuery为例</p><h5 id="安装-5"><a href="#安装-5" class="headerlink" title="安装"></a>安装</h5><p><code>npm i --save jquery</code><br>我们需要在生产环境中使用，用 –save安装</p><h5 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h5><p><code>import $ from jquery</code></p><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p><code></code>$(‘#title’)<code>.html(&#39;Hello JQuery&#39;)</code></p><h5 id="用pligin引入"><a href="#用pligin引入" class="headerlink" title="用pligin引入"></a>用pligin引入</h5><p>ProvidePlugin是webpack自带的插件<br><code>const webpack = require(&#39;webpack&#39;)</code><br>配置plugins<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">new webpack.ProvidePlugin(&#123;</span><br><span class="line">    $:&apos;jquery&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p></p><h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><p>watch的配置<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watchOptions:&#123;</span><br><span class="line">//检测修改的时间</span><br><span class="line">poll:1000,</span><br><span class="line">    //防止重复保存编译错误</span><br><span class="line">    aggregateTimeout:500,</span><br><span class="line">    //不监听的目录</span><br><span class="line">    ignored:/node_modules/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="文件代码注释"><a href="#文件代码注释" class="headerlink" title="文件代码注释"></a>文件代码注释</h4><p><code>new webpack.BannerPlugin(&#39;作者：xxx&#39;)</code></p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><h5 id="ProvidePlugin和import"><a href="#ProvidePlugin和import" class="headerlink" title="ProvidePlugin和import"></a>ProvidePlugin和import</h5><ul><li>import引入方法：引用后不管你在代码中使用不适用该类库，都会把该类库打包起来，这样有时就会让代码产生冗余。</li><li>ProvidePlugin引入方法：引用后只有在类库使用时，才按需进行打包，所以建议在工作使用插件的方式进行引入。</li></ul><h5 id="代码抽离"><a href="#代码抽离" class="headerlink" title="代码抽离"></a>代码抽离</h5><p>在新版中我们废弃并移除了 CommonsChunkPlugin，并且使用一些默认值以及更容易被复写的新 API optimize.splitChunks 来代替它。</p><h4 id="静态资源集中输出"><a href="#静态资源集中输出" class="headerlink" title="静态资源集中输出"></a>静态资源集中输出</h4><p><code>npm i -D copy-webpack-pligin</code><br>同样的引入，配置<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new copyWebpackPlugin([&#123;</span><br><span class="line">from:__diname + &apos;/src/public&apos;,</span><br><span class="line">    to:&apos;./public&apos;</span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure><p></p><h4 id="json"><a href="#json" class="headerlink" title="json"></a>json</h4><h4 id="打包前清空dist"><a href="#打包前清空dist" class="headerlink" title="打包前清空dist"></a>打包前清空dist</h4><p><code>npm i -D clean-webpack-plugin</code><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">new cleanWebpackPlugin([path.join(__dirname,&apos;dist&apos;)])</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;安装webpack&quot;&gt;&lt;a href=&quot;#安装webpack&quot; class=&quot;headerlink&quot; title=&quot;安装webpack&quot;&gt;&lt;/a&gt;安装webpack&lt;/h4&gt;&lt;h5 id=&quot;对项目初始化&quot;&gt;&lt;a href=&quot;#对项目初始化&quot; class=&quot;head
      
    
    </summary>
    
      <category term="技术类" scheme="https://jadedoo.github.io/categories/%E6%8A%80%E6%9C%AF%E7%B1%BB/"/>
    
    
      <category term="webpack" scheme="https://jadedoo.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack</title>
    <link href="https://jadedoo.github.io/post/b9f20a20/"/>
    <id>https://jadedoo.github.io/post/b9f20a20/</id>
    <published>2018-04-17T11:11:53.000Z</published>
    <updated>2018-04-21T15:41:21.853Z</updated>
    
    <content type="html"><![CDATA[<p>写这篇文章的只是一个前端小白，如果有错误的地方，还请指出来。。。<br>什么是webpack？<br>webpack简单的来说就是一个打包器。处理应用程序的时候，它会创建一个依赖关系图，然后将这些模块打包一个或多个bundle。<br>webpack4.0之后，可以不用引入配置文件。</p><p>###Entry<br>所有的webpack配置都写在webpack.config.js文件里</p><ul><li><p>入口文件配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const config = &#123;</span><br><span class="line">  entry: &apos;./src/index.js&apos;</span><br><span class="line">&#125;;</span><br><span class="line">module.exports = config;</span><br></pre></td></tr></table></figure></li><li><p>多个页面应用程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    page1: &apos;./src/page1/index.js&apos;,</span><br><span class="line">    page2: &apos;./src/page2/index.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">module.exports = config;</span><br></pre></td></tr></table></figure></li></ul><p><code>每个 HTML 文档只使用一个入口起点。</code></p><p>###Output<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    page1: &apos;./src/page1/index.js&apos;,</span><br><span class="line">    page2: &apos;./src/page2/index.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;[name].bundle.js&apos;,</span><br><span class="line">    path: __dirname + &apos;/dist&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">module.exports = config;</span><br></pre></td></tr></table></figure><p></p><p>###Mode<br>webpack一个有两种模式，production和developement<br>可以在配置文件中写入<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &apos;production&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>或者在CLI中传递参数<br>webpack –mode=production</p><p>###Loder<br>loder用于转换其他格式的文件，webpack本身只能识别js。<br>要使用loder你需要先下载对应的loder<br><code>npm install --save-dev css-loder</code><br>在webpack.config.js中配置loder<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    test: /\.css$/,</span><br><span class="line">    use: [</span><br><span class="line">      &#123;loader: &apos;style-loader&apos;&#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        loder:&apos;css-loader&apos;,</span><br><span class="line">        options:&#123;</span><br><span class="line">          modules: true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>###Plugins<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //通过 npm 安装</span><br><span class="line">const webpack = require(&apos;webpack&apos;); //访问内置的插件</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">const config = &#123;</span><br><span class="line">  entry: &apos;./path/to/my/entry/file.js&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;my-first-webpack.bundle.js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(js|jsx)$/,</span><br><span class="line">        use: &apos;babel-loader&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;template: &apos;./src/index.html&apos;&#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = config;</span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写这篇文章的只是一个前端小白，如果有错误的地方，还请指出来。。。&lt;br&gt;什么是webpack？&lt;br&gt;webpack简单的来说就是一个打包器。处理应用程序的时候，它会创建一个依赖关系图，然后将这些模块打包一个或多个bundle。&lt;br&gt;webpack4.0之后，可以不用引入
      
    
    </summary>
    
    
      <category term="webpack" scheme="https://jadedoo.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>VS Code前端插件</title>
    <link href="https://jadedoo.github.io/post/71cfa6a3/"/>
    <id>https://jadedoo.github.io/post/71cfa6a3/</id>
    <published>2018-04-13T03:49:11.000Z</published>
    <updated>2018-04-13T04:25:10.995Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>名称</th><th>功能</th></tr></thead><tbody><tr><td>Auto Close Tag</td><td>自动闭合HTML标签</td></tr><tr><td>Auto Import Typescript</td><td>自动import提示</td></tr><tr><td>Auto Rename Tag</td><td>修改HTML标签时，自动修改匹配的标签</td></tr><tr><td>Beautify</td><td>格式化javascript，JSON，CSS，Sass，和HTML</td></tr><tr><td>Class autocomplete for HTML</td><td>智能提示HTML class =“”属性（必备）</td></tr><tr><td>Bracket Pair Colorizer</td><td>颜色识别匹配括号</td></tr><tr><td>Code Runner</td><td>运行选中代码段（支持大量语言，包括Node）</td></tr><tr><td>css peek</td><td>能够查看CSS ID和类的字符串作为HTML文件中相应的CSS定义（必备）</td></tr><tr><td>Color Highlight</td><td>颜色值在代码中高亮显示</td></tr><tr><td>Color Info</td><td>小窗口显示颜色值，rgb,hsl,cmyk,hex等等</td></tr><tr><td>Document This</td><td>添加注释块(Ctrl+alt+d)</td></tr><tr><td>ESLint</td><td>ESLint插件，高亮提示</td></tr><tr><td>Git History</td><td>以图表的形式查看git日志(Ctrl+shift+p)</td></tr><tr><td>HTML CSS Support</td><td>在 html 标签上写class 智能提示当前项目所支持的样式（必备）</td></tr><tr><td>HTML Snippets</td><td>html 代码片段（必备）</td></tr><tr><td>htmlhint</td><td>html代码检测</td></tr><tr><td>htmltagwrap</td><td>可以在选中HTML标签中外面套一层标签(Alt + W)</td></tr><tr><td>IntelliSense for CSS class names</td><td>智能提示 css 的 class 名</td></tr><tr><td>JavaScript (ES6) code snippets</td><td>es6代码片段（必备）</td></tr><tr><td>JavaScript Snippet Pack</td><td>js代码片段（必备）</td></tr><tr><td>Live Sass Compiler</td><td>实时编译 sass</td></tr><tr><td>open in browser</td><td>当前的 html 文件用浏览器打开(alt+b)</td></tr><tr><td>Output Colorizer</td><td>输出提示的文字颜色有一些变化，方便获取关键信息</td></tr><tr><td>Path Intellisense</td><td>路径自动补全（必备）</td></tr><tr><td>Sass</td><td>写 sass 必备</td></tr><tr><td>Quokka.js</td><td>实时观看 javascript 的变量的变化(shift+cmd+p （ctrl+shift+p）输入quokka选择new javascript)</td></tr><tr><td>Regex Previewer</td><td>测试正则的插件</td></tr><tr><td>vscode-icons</td><td>目录树图标</td></tr><tr><td>Dracula Official</td><td>主题插件。。。</td></tr><tr><td>React-Native/React/Redux snippets for es6/es7</td><td>react代码片段</td></tr><tr><td>react-beautify</td><td>格式化 javascript, JSX, typescript, TSX 文件</td></tr><tr><td>vetur</td><td>vue语法高亮、智能感知</td></tr><tr><td>VueHelper</td><td>vue代码片段</td></tr><tr><td>Vue TypeScript Snippets</td><td>vue的 typescript 代码片段</td></tr><tr><td>Vue 2 Snippets</td><td>vue 2代码片段</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;名称&lt;/th&gt;&lt;th&gt;功能&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Auto Close Tag&lt;/td&gt;&lt;td&gt;自动闭合HTML标签&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Auto Import Typescrip
      
    
    </summary>
    
      <category term="应用类" scheme="https://jadedoo.github.io/categories/%E5%BA%94%E7%94%A8%E7%B1%BB/"/>
    
    
      <category term="Tools" scheme="https://jadedoo.github.io/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>GitHub利用Hexo搭建博客</title>
    <link href="https://jadedoo.github.io/post/c3d89d7f/"/>
    <id>https://jadedoo.github.io/post/c3d89d7f/</id>
    <published>2018-04-12T13:25:26.000Z</published>
    <updated>2018-04-13T09:28:02.692Z</updated>
    
    <content type="html"><![CDATA[<p>想要利用hexo和GitHub page搭建自己的博客，首先就要安装必要的工具。<strong><em> 在那之前你需要在<a href="https://github.com/" target="_blank" rel="noopener">Github</a>上注册一个账号。</em></strong></p><h3 id="第一：安装nodejs"><a href="#第一：安装nodejs" class="headerlink" title="第一：安装nodejs"></a>第一：安装nodejs</h3><p>不会安装的可以看我的另外一篇文章 <a href="../利用3M安装nodejs/index.html">传送门</a></p><h3 id="第二：安装git"><a href="#第二：安装git" class="headerlink" title="第二：安装git"></a>第二：安装git</h3><p>直接到官网下载安装包，傻瓜式安装。 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">传送门</a>。</p><h4 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h4><p>在任意地方右键运行git bash，执行命令<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;yourname&quot;</span><br><span class="line">$ git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure><p></p><p>其中yourname为你的GitHub名，youremail为你的GitHub邮箱。<br>继续执行<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure><p></p><p>可以在用户文件夹里看到一个<code>.ssh</code>文件，打开其中的<code>.pub</code>后缀名的文件，复制里面的内容。<br>打开GitHub网站，点击头像，选择setting，找到 SSH and GPG keys<br><img src="http://p746ve2cn.bkt.clouddn.com/201804131610_811.png" alt=""><br><img src="http://p7490al8l.bkt.clouddn.com/201804131714_243.png" alt=""><br>点击右侧的<code>new SSH key</code><br><img src="http://p7490al8l.bkt.clouddn.com/201804131721_534.png" alt=""><br>把刚才复制的内容粘贴到<code>key</code>里<br><img src="http://p7490al8l.bkt.clouddn.com/201804131724_577.png" alt=""></p><h3 id="第三：安装hexo"><a href="#第三：安装hexo" class="headerlink" title="第三：安装hexo"></a>第三：安装hexo</h3><p>新建一个已准备存放blog的文件夹，在该文件目录下右键运行<code>git bash here</code>，输入<code>npm i -g hexo</code>，执行完毕后，输入<code>hexo -v</code>，出现版本号证明安装成功。</p><h3 id="第四：配置"><a href="#第四：配置" class="headerlink" title="第四：配置"></a>第四：配置</h3><ol><li>在BLOG文件夹中运行<code>git bash</code>，然后执行初始化命令<code>$ hexo init</code>。这时候hexo会自动生成说需要的文件。</li><li>执行完毕之后我们可以执行<code>$ hexo s --debug</code>命令打开hexo自带的服务器，默认端口号为4000。点击<a href="http://localhost:4000/" target="_blank" rel="noopener">localhost:4000</a></li><li>如果成功的话就可以看见hexo默认的模板页面，用<code>$ hexo new page &quot;name&quot;</code>新建文章，你可以随便写点内容，现在我们就要将它发布到网上去。不过在那之前，还需要在GitHub上新建一个仓库和配置一下<code>站点配置文件</code></li><li>打开blog文件根目录中找到<code>config.yml</code>文件，修改里面的部分内容。</li></ol><p>###第五：关联仓库<br>在此之前需要创建一个仓库</p><ol><li>点击<code>New reporitory</code>，新建仓库。<br><img src="http://p7490al8l.bkt.clouddn.com/201804131725_591.png" alt=""></li><li>注意这里的仓库名称必须是此格式，<code>yourname.github.io</code>。其中yourname是你的github名称。<br><img src="http://p7490al8l.bkt.clouddn.com/201804131727_795.png" alt=""></li><li>仓库有了，把本地blog上传到仓库。执行<code>$ hexo g -d</code>命令。<br>一切准备就绪，可以打开你的个人博客。GitHub page 网站格式 <code>yourname.github.io</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想要利用hexo和GitHub page搭建自己的博客，首先就要安装必要的工具。&lt;strong&gt;&lt;em&gt; 在那之前你需要在&lt;a href=&quot;https://github.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;上注册一个
      
    
    </summary>
    
      <category term="应用类" scheme="https://jadedoo.github.io/categories/%E5%BA%94%E7%94%A8%E7%B1%BB/"/>
    
    
      <category term="Hexo" scheme="https://jadedoo.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>利用3M安装nodejs</title>
    <link href="https://jadedoo.github.io/post/c80c1044/"/>
    <id>https://jadedoo.github.io/post/c80c1044/</id>
    <published>2018-04-11T18:11:00.000Z</published>
    <updated>2018-04-12T14:54:39.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nodejs在window下安装"><a href="#nodejs在window下安装" class="headerlink" title="nodejs在window下安装"></a>nodejs在window下安装</h2><p>nodejs有很多中安装方式，本篇文章使用的是nvm(nodejs version manager,版本管理工具)方式来进行安装。详情请查看<a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="noopener">【官方文档】</a>。</p><h3 id="安装nvm"><a href="#安装nvm" class="headerlink" title="安装nvm"></a>安装nvm</h3><ol><li><p>首先<a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">下载nvm包</a>,我们选择我们需要的免安装版:nvm-noinstall.zip,下载完成后解压,解压到你想要解压的地方就好,例如:C:\dev\nvm,文件包含:</p><ul><li>elevate.cmd</li><li>elevate.vbs</li><li>install.cmd</li><li>LICENSE</li><li>nvm.exe</li></ul></li><li><p>运行install.cmd,直接回车,会在C盘的根目录下生成settings.txt文件，将这个文件剪切到C:\dev\nvm目录中修改其中的内容</p><blockquote><p>root: C:\dev\nvm<br>path: C:\dev\nodejs<br>proxy: none<br>node_mirror: <a href="http://npm.taobao.org/mirrors/node/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/node/</a><br>npm_mirror: <a href="https://npm.taobao.org/mirrors/npm/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/npm/</a></p></blockquote></li><li><p>配置环境变量，运行了install.cmd，所以直接在环境变量中找到并修改<code>NVM_HOME:C:\dev\nvm,NVM_SYMLINK:C:\dev\nodejs</code><br>然后修改path，如果发现path中有路径<code>C:\dev\nvm</code>，就将它删除，我们自己在最前面添加’ ;%NVM_HOME%;%NVM_SYMLINK%;’</p></li><li><p>运行cmd，输入 ‘nvm -v’ 显示版本号证明安装成功，注意它会显示一堆东西，往上拉就可以看见版本号,然后就可以安装nodejs了。<br></p></li><li>输入 <code>nvm install lastest</code> 安装最新版的nodejs，如果不想下载最新版则输入<code>nvm install 版本号</code>，例如 <code>nvm install 7.9.0</code>，32位的电脑还得在后面添加一个<code>32</code>。</li><br><li>这是打开<code>C:\dev</code>会发现有一个<code>noedjs</code>文件夹的快捷方式，它指向的就是<code>C:\dev\nvm</code>中nodejs的版本文件夹，例如<code>v7.9.0</code></li><br><li>运用nvm可以进行版本切换，<code>nvm use 版本号</code>，前提是得有这个版本。</li><br><li>输入nvm list 可以查看目前安装了几个nodejs版本和正在使用哪个版本。</li><br><p></p></ol><h3 id="安装npm"><a href="#安装npm" class="headerlink" title="安装npm"></a>安装npm</h3><li>npm(nodejs package manager，nodejs包管理工具)，每一个版本的nodejs都会自带一个npm，但是有时候明明安装了包，却无法使用，其中就有可能是因为版本切换问题而引起的，所以需要安装一个全局的npm。</li><br><li>运行cmd，输入<code>npm config set prefix “C:\dev\nvm\npm</code>，运行完成后可以在用户文件夹中找到一个<code>.npmrc</code>的文件，里面存的是一个路径。</li><br><li>继续输入<code>npm install npm -g</code>，等待下载。这是可以在<code>C:\dev\nvm\npm</code>中查看文件，以后需要安装全局包在后面加一个<code>-g</code>就好了。</li><br><li>当然，需要单独为全局npm配置环境变量<br><code>NPM_HOME:C:\dev\nvm\npm</code></li><br><li>在path最前面加上<code>;%NPM_HOME%</code>，这个是必须加载<code>%NVM_SYMLINK%</code>之前的，</li><li>输入 <code>npm -v</code> 显示版本号证明安装成功。</li><p></p><h3 id="安装nrm"><a href="#安装nrm" class="headerlink" title="安装nrm"></a>安装nrm</h3><p></p><p></p><li>nrm(npm registry manager，npm的镜像源管理工具)，这是为了切换镜像源，为什么需要？有时候国外的资源太慢，我们需要切换国内的资源点。</li><p></p><p></p><li>运行cmd，输入<code>npm install -g nrm</code>，等待下载安装完毕。</li><p></p><p></p><li>输入<code>nrm ls</code>，可以查看所有的可切换源地址。</li><p></p><p></p><li>一般来说国内的肯定比国外的要快，所以我们一般用淘宝的镜像地址，输入<code>nrm use cnpm</code>就可以切换了。</li><br><p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;nodejs在window下安装&quot;&gt;&lt;a href=&quot;#nodejs在window下安装&quot; class=&quot;headerlink&quot; title=&quot;nodejs在window下安装&quot;&gt;&lt;/a&gt;nodejs在window下安装&lt;/h2&gt;&lt;p&gt;nodejs有很多中安装方式
      
    
    </summary>
    
      <category term="应用类" scheme="https://jadedoo.github.io/categories/%E5%BA%94%E7%94%A8%E7%B1%BB/"/>
    
    
      <category term="NodeJs" scheme="https://jadedoo.github.io/tags/NodeJs/"/>
    
  </entry>
  
</feed>
